# 数据结构与算法

# 栈 队列 链表
## 数组实现栈
```
// es5
var Stack = function(){
    var items = [];
    this.push = function(element){
        items.push(element);
    }
    this.pop = function(){
        return items.pop();
    }
    // 检查栈顶元素
    this.peek = function(){
        return items[items.length-1];
    }
    // 检查栈是否为空
    this.isEmpty = function(){
        return items.length == 0;
    }
    // 检查整个数组
    this.getItems = function(){
        return items;
    }
    // 清除整个栈
    this.clear = function(){
        items = [];
    }
    // 获取栈的大小
    this.size = function(){
        return items.length;
    }
}


// 先调用 先入栈
// 后进先出 先执行 

function fun1(){
    console.log(1);
}
function fun2(){
    fun1();
    console.log(2);
}
fun2();
```
## 数组实现队列
```
var Queue = function () {
    var items = [];

    // 添加一个元素到数组的最后
    // 入列
    this.enqueue = function (element) {
        items.push(element);
    }

    // 出列
    this.dequeue = function () {
        return items.shift();// 清除数组第一个元素
    }

    // 查看队列头
    this.front = function () {
        return items[0];
    }

    // 查看队列是否为空
    this.isEmpty = function () {
        return items.length == 0;
    }

    // 查看队列大小
    this.size = function () {
        return items.length;
    }
}
```
## 链表
```
var LikeList = function(){
    // 链表头和长度
    var head = null;// Object类型
    var length = 0;
    // 辅助类 形参不需要null，函数自动指定
    var Node = function(element){
        this.element = element;
        this.next = null;

    }

    // 向链表尾部添加元素
    this.append = function(element){
        var node = new Node(element);
        // node = {
            // element: element,
            // next : null
        // }
        if(head == null){
            head = node;
        }
        else{
            var current = head;
            while(current.next){
                current = current.next;
            }
            // 执行完后 current已经到达链表最后
            current.next = node;
        }
        length++;
    }

    // 向链表中间某一个位置添加元素
    // 参数是position位置和element 元素
    this.insert = function(position,element){
        var node = new Node(element)
        // 越界问题
        if(position > -1 && position < length){
            if(position == 0){
                // 向链表头（position = 0）添加元素
                var current = head;// 保存原来的head
                head = node; // head设置为要添加的node
                head.next = current;// 原来的head放到新head后面
            }
            else{
                var index = 0;
                var current = head;
                var previous = null;
                while(index < position){
                    previous = current;
                    current = current.next;
                    index++;
                }
                previous.next = node;
                node.next = current;
            }
            length++;
        }
    }

    // 删除链表中某一个元素
    // 参数是position位置
    this.removeAt = function(position){
        // 越界问题
        if(position > -1 && position < length){
            // 删除链表头
            if(position == 0){
                var current = head;// 保存原来的head
                head = current.next;// 原来的head设置为第二个
            }
            // 删除链表中间某一个元素
            else{
                var index = 0;
                var current = head;
                var previous = null;
                while(index < position){
                    previous = current;
                    current = current.next;
                    index++;
                }
                previous.next = current.next;
            }
            length--;
            return current;
        }
        return null;
    }

    // 查找某一个元素的位置
    this.indexOf = function(element){
        var current = head;
        var index = 0;
        while(current){
            if(current.element == element){
                return index;
            }
            current = current.next;
            index++
        }

        // 如果全部没有找到 返回-1
        return -1;

    }


    this.getHead = function(){
        return head;
    }


    // removeAt(position) 删除某个位置的元素
    // indexOf(element) 查找某个元素的位置
    // 综合起来的方法 实现代码复用
    this.remove =  function(element){
        return this.removeAt(this.indexOf(element));
    }

    // 判断是否是空链表
    this.isEmpty = function(){
        return length == 0;// 判断句 输出Boolean
    }


    this.size = function(){
        return length;
    }
}

// 链表和字符串？？？

var l = new LikeList;
l.append(1)
l.append(2)
l.append(3)
l.append(4)
l.insert(2,999)
```
# 集合


# 算法
# 排序算法
## 冒泡排序
## 选择排序
## 插入排序
## 归并排序

# 搜索算法
## 顺序搜索
## 二分搜索

# 算法模式
## 递归 动态规划 贪心算法
