# 数据结构与算法

# 栈 队列 链表
## 数组实现栈
```
// es5
var Stack = function(){
    var items = [];
    this.push = function(element){
        items.push(element);
    }
    this.pop = function(){
        return items.pop();
    }
    // 检查栈顶元素
    this.peek = function(){
        return items[items.length-1];
    }
    // 检查栈是否为空
    this.isEmpty = function(){
        return items.length == 0;
    }
    // 检查整个数组
    this.getItems = function(){
        return items;
    }
    // 清除整个栈
    this.clear = function(){
        items = [];
    }
    // 获取栈的大小
    this.size = function(){
        return items.length;
    }
}


// 先调用 先入栈
// 后进先出 先执行 

function fun1(){
    console.log(1);
}
function fun2(){
    fun1();
    console.log(2);
}
fun2();
```
## 数组实现队列
```
var Queue = function () {
    var items = [];

    // 添加一个元素到数组的最后
    // 入列
    this.enqueue = function (element) {
        items.push(element);
    }

    // 出列
    this.dequeue = function () {
        return items.shift();// 清除数组第一个元素
    }

    // 查看队列头
    this.front = function () {
        return items[0];
    }

    // 查看队列是否为空
    this.isEmpty = function () {
        return items.length == 0;
    }

    // 查看队列大小
    this.size = function () {
        return items.length;
    }
}
```
## 链表
```
var LikeList = function(){
    // 链表头和长度
    var head = null;// Object类型
    var length = 0;
    // 辅助类 形参不需要null，函数自动指定
    var Node = function(element){
        this.element = element;
        this.next = null;

    }

    // 向链表尾部添加元素
    this.append = function(element){
        var node = new Node(element);
        // node = {
            // element: element,
            // next : null
        // }
        if(head == null){
            head = node;
        }
        else{
            var current = head;
            while(current.next){
                current = current.next;
            }
            // 执行完后 current已经到达链表最后
            current.next = node;
        }
        length++;
    }

    // 向链表中间某一个位置添加元素
    // 参数是position位置和element 元素
    this.insert = function(position,element){
        var node = new Node(element)
        // 越界问题
        if(position > -1 && position < length){
            if(position == 0){
                // 向链表头（position = 0）添加元素
                var current = head;// 保存原来的head
                head = node; // head设置为要添加的node
                head.next = current;// 原来的head放到新head后面
            }
            else{
                var index = 0;
                var current = head;
                var previous = null;
                while(index < position){
                    previous = current;
                    current = current.next;
                    index++;
                }
                previous.next = node;
                node.next = current;
            }
            length++;
        }
    }

    // 删除链表中某一个元素
    // 参数是position位置
    this.removeAt = function(position){
        // 越界问题
        if(position > -1 && position < length){
            // 删除链表头
            if(position == 0){
                var current = head;// 保存原来的head
                head = current.next;// 原来的head设置为第二个
            }
            // 删除链表中间某一个元素
            else{
                var index = 0;
                var current = head;
                var previous = null;
                while(index < position){
                    previous = current;
                    current = current.next;
                    index++;
                }
                previous.next = current.next;
            }
            length--;
            return current;
        }
        return null;
    }

    // 查找某一个元素的位置
    this.indexOf = function(element){
        var current = head;
        var index = 0;
        while(current){
            if(current.element == element){
                return index;
            }
            current = current.next;
            index++
        }

        // 如果全部没有找到 返回-1
        return -1;

    }


    this.getHead = function(){
        return head;
    }


    // removeAt(position) 删除某个位置的元素
    // indexOf(element) 查找某个元素的位置
    // 综合起来的方法 实现代码复用
    this.remove =  function(element){
        return this.removeAt(this.indexOf(element));
    }

    // 判断是否是空链表
    this.isEmpty = function(){
        return length == 0;// 判断句 输出Boolean
    }


    this.size = function(){
        return length;
    }
}

// 链表和字符串？？？

var l = new LikeList;
l.append(1)
l.append(2)
l.append(3)
l.append(4)
l.insert(2,999)
```
# 集合
使用属性模拟集合     
键值对相同 都是元素值
```
var Set2 = function () {
    var items = {};
    var length = 0;

    // 检查元素是否存在
    this.has = function (value) {
        return items.hasOwnProperty(value);
    }

    // add
    this.add = function (value) {
        // 集合中没有这个元素才添加
        if (!this.has(value)) {
            items[value] = value;
            // 方括号语法
            // 对象属性和属性值相同
            length++;
            return value
        }
        else {
            return false;
        }

    }

    // 删除
    this.remove = function (value) {
        if (this.has(value)) {
            delete items[value];
            length--;
            return true;
        }
        else {
            return null;
        }
    }

    // 检查
    this.getItems = function () {
        return items;
    }


    // 清空
    this.clear = function () {
        items = {};
        length = 0;
        return '集合已清空';
    }

    // size
    this.size = function () {
        // 方法一：集合中每添加（删除）一个元素，length++（--）
        // 1、return length;

        // 方法二：for in 循环遍历完集合中所有元素
        // var count = 0;
        // for (let i in items) {
        //     count++;
        // }
        // return count;

        // 方法三：
        return Object.keys(items).length;
    }


    // 并集
    this.valueSet = function () {
        var values = [];
        for (let i in items) {
            if (items.hasOwnProperty(i)) {
                values.push(items[i]);
            }
        }
        // 该方法把集合中所有元素存入数组
        return values;
    }
    this.union = function (otherset) {
        var resultSet = new Set2();
        // 1、
        // 把原集合中所有元素都提取出来
        // 放到一个数组
        var arr = this.valueSet();
        for (let i = 0; i < arr.length; i++) {
            // 通过遍历把数组中所有元素添加（add方法）到resultSet汇总
            resultSet.add(arr[i]);
        }


        // 2、
        // 把新集合中所有元素都提取出来
        // 放到一个数组
        var arr = otherset.valueSet();
        for (let i = 0; i < arr.length; i++) {
            // 通过遍历把数组中所有元素添加（add方法）到新集合汇总
            resultSet.add(arr[i]);
        }

        // add方法已经调用has方法判断是否存在这个元素
        // 实现去重
        return resultSet;
    }


    // 交集
    this.innn = function(otherset){
        var resultSet = new Set2();
        var arr = this.valueSet();
        for (let i = 0; i < arr.length; i++) {
            if(otherset.has(arr[i])){
                resultSet.add(arr[i]);
            }
        }
        return resultSet;
    }


    // 差集
    this.difference = function(otherset){
        var resultSet = new Set2();
        // 遍历原集和中的所有元素 存入数组
        var arr = this.valueSet();
        for(var i = 0;i<arr.length;i++){
            if(!otherset.has(arr[i])){
                resultSet.add(arr[i]);
            }
        }
        return resultSet;

    }

}



var s = new Set2();
s.add(1);
s.add(2);
s.add(3);
s.add(4);

var s2 = new Set2()
s2.add(111);
s2.add(3);
s2.add(12);
s2.add(1);

var res = s.union(s2);// 1 2 3 4 12 111
var res2 = s.innn(s2);// 1 3 
var res3 = s.difference(s2);// 2 4 
```
## forEach
```
// es6
var s = new Set();
s.add(1);
s.add(2);
s.add(3);
s.add(4);
s.add(1);

s.forEach((item,index,set) => {
    console.log('item '+ item);
    console.log('index '+index);
    console.log('set ' + set);
})


// 遍历数组
var arr = ['a','b','c'];
// 第一个参数是元素
// 第二个参数是数组中元素对应的下标

arr.forEach((item,index) => {
    console.log(item,index);
})
```

## ES6集合（set）
```

// es6set的并集交集差集
var a = new Set([1,2,3,4]);
var b = new Set([3,4,5,6]);
// 并集
var res = new Set([...a,...b]);
// ...运算符 解构成单个数值

// var arr = [1,-10,22,-45];
// // filter过滤器  过滤器里的函数返回true，则把数据添加到数组里
// // 把arr中所有大于0 的元素提取出来
// var arr2 = arr.filter(function(value){
//     if(value > 0)
//     return true;
// })

// 交集
var intersect = new Set([...a].filter(x => b.has(x)));
// 解构a
// 过滤器：b里面有a解构出来的x 则return true
// 把a解构出来的数据和b返回过来a也有的数据添加到一个set容器

// 差集
var difference = new Set([...a].filter(x => !b.has(x)));


```
## 引用
set强引用  
```
var set01 = new Set()
var obj01 = {
    name: 'jrj',
    age:19
}
set01.add(obj01);
obj01 = null;
// 此时obj虽然失去引用，本应该被回收
// 但是把obj01原本在内存中的数据添加给了set01依然保持强引用
// 不会被回收
```
需要通过set.delete()删除该引用  


weakset弱引用 清空后无妨通过引用访问  
比强引用更灵活  


# 字典
```
// 字典
var Dictionary = function () {
    var items = {};

    // 检查
    this.has = function (key) {
        return items.hasOwnProperty(key);

        // 方法二
        //    return key in items; 
    }

    // 添加
    this.set = function(key,value){
        items[key] = value;
    }

    // 删除
    this.delete = function(key){
        if(this.has(key)){
            // 存在该元素 删除
            delete items[key];
            return true;
        }
        else{
            return '删除失败！'
        }
    }

    // 获取
    this.getItem = function(key){
        if(this.has(key)){
            return items[key];
        }
        else{
            return undefined;
        }
    }
    this.getItems = function(){
        return items;
    }
}


var d = new Dictionary;
d.set('name','景仁杰');
d.set('age',18);
```

## 哈希表
```
// 哈希表
var HashTable = function(){
    var items = [];

    // 散列函数
    // 通过ASCii码key -> number -> items[number]
    // a => 97  A => 65
    var loseloseHashCode = function(key){
        var hash = 0;
        for(var i =0;i<key.length;i++){
            // 利用字符串遍历下标得到所有字符的ASCII值之和
            hash += key[i].charCodeAt();
        }
        return hash % 37;// 约定俗成
        // 获取key 的散列值
        // 作为数组的下标
    }

    // 添加
    this.put = function(key,value){
        var position = loseloseHashCode(key);
        items[position] = value;
        console.log(position+'-'+value);

    }

    // 获取
    this.getItem = function(){
        return items;
    }

    this.get = function(key){
        return items[loseloseHashCode(key)];
    }

    // 删除
    this.remove = function(key){
        items[loseloseHashCode(key)] = undefined;
        return true;
    }
}

var d = new HashTable();
d.put('Jobs',"语文");
d.put('Bob',"数学");
d.put('Jack',"英语");

```

### 哈希表的散列值冲突问题
当两个散列值相同时，可能会存储到相同的位置，导致数据丢失  


分离链接法   
相同的散列值数据存储到一个链表里，一条街（哈希表）同一门牌号存到同一个巷子里（链表）  
纵横  
```
//-----------------------------------------------------
// 虚线内为链表
var LikeList = function () {
    // 链表头和长度
    var head = null;// Object类型
    var length = 0;
    // 辅助类 形参不需要null，函数自动指定
    var Node = function (element) {
        this.element = element;
        this.next = null;

    }

    // 向链表尾部添加元素
    this.append = function (element) {
        var node = new Node(element);
        // node = {
        // element: element,
        // next : null
        // }
        if (head == null) {
            head = node;
        }
        else {
            var current = head;
            while (current.next) {
                current = current.next;
            }
            // 执行完后 current已经到达链表最后
            current.next = node;
        }
        length++;
    }

    // 向链表中间某一个位置添加元素
    // 参数是position位置和element 元素
    this.insert = function (position, element) {
        var node = new Node(element)
        // 越界问题
        if (position > -1 && position < length) {
            if (position == 0) {
                // 向链表头（position = 0）添加元素
                var current = head;// 保存原来的head
                head = node; // head设置为要添加的node
                head.next = current;// 原来的head放到新head后面
            }
            else {
                var index = 0;
                var current = head;
                var previous = null;
                while (index < position) {
                    previous = current;
                    current = current.next;
                    index++;
                }
                previous.next = node;
                node.next = current;
            }
            length++;
        }
    }

    // 删除链表中某一个元素
    // 参数是position位置
    this.removeAt = function (position) {
        // 越界问题
        if (position > -1 && position < length) {
            // 删除链表头
            if (position == 0) {
                var current = head;// 保存原来的head
                head = current.next;// 原来的head设置为第二个
            }
            // 删除链表中间某一个元素
            else {
                var index = 0;
                var current = head;
                var previous = null;
                while (index < position) {
                    previous = current;
                    current = current.next;
                    index++;
                }
                previous.next = current.next;
            }
            length--;
            return current;
        }
        return null;
    }

    // 查找某一个元素的位置
    this.indexOf = function (element) {
        var current = head;
        var index = 0;
        while (current) {
            if (current.element == element) {
                return index;
            }
            current = current.next;
            index++
        }

        // 如果全部没有找到 返回-1
        return -1;

    }


    this.getHead = function () {
        return head;
    }


    // removeAt(position) 删除某个位置的元素
    // indexOf(element) 查找某个元素的位置
    // 综合起来的方法 实现代码复用
    this.remove = function (element) {
        return this.removeAt(this.indexOf(element));
    }

    // 判断是否是空链表
    this.isEmpty = function () {
        return length == 0;// 判断句 输出Boolean
    }


    this.size = function () {
        return length;
    }
}
//---------------------------------------------------------------- 

var HashTable_L = function () {
    var table = [];
    // 散列函数
    var loseloseHashCode = function (key) {
        var hash = 0;
        for (var i = 0; i < key.length; i++) {
            // 利用字符串遍历下标得到所有字符的ASCII值之和
            hash += key[i].charCodeAt();
        }
        return hash % 37;
    }

    // 辅助类
    var Node = function (key, value) {
        this.key = key;
        this.value = value;
    }
    // 因为后续需要在链表中查找数据，所以需要保存同一散列值下所有元素的key和value
    // 所以创建辅助类
    // 保存键值对，以便在链表中查找
    this.put = function (key, value) {
        var position = loseloseHashCode(key);
        if (table[loseloseHashCode(key)]) {
            // 2、散列表中已有散列值对应的元素，向该散列值后面的链表中添加元素
            table[position].append(new Node(key, value));
        }
        else {
            var l = new LikeList;
            table[position] = l;// 1、散列表中没有很散列值对应的元素 创建链表 存入第一个
            table[position].append(new Node(key, value));
        }
    }


    // 获取单个元素
    this.get = function (key) {
        if (table[loseloseHashCode(key)]) {
            // 如果散列值对应的元素存在
            var current = table[loseloseHashCode(key)].getHead();
            // 遍历链表
            while (current) {
                // 如果链表中某个Node的element（包含key-value）的key和要找的key一样
                if (current.element.key == key) {
                    return current.element;
                }
                // 链表向后移动
                current = current.next;
            }
        }
        else {
            // 散列值对应的元素不存在 直接返回undefined
            return '找不到';
        }
    }
    // 获取整个哈希表
    this.getItems = function () {
        return table;
    }



    // 删除单个元素
    this.remove = function (key) {
        if (table[loseloseHashCode(key)]) {
            // 如果散列值对应的元素存在
            var current = table[loseloseHashCode(key)].getHead();
            // 遍历链表
            while (current) {
                // 如果链表中某个Node的element（包含key-value）的key和要找的key一样
                if (current.element.key == key) {
                    table[loseloseHashCode(key)].remove(current.element);
                    // 对应的链表----------------链表里面的删除方法--节点的element传入删除

                    // 如果链表只有一个元素或者删除为空后，需要将链表复位为undefined
                    // 否则存储很多空链表将占用很多内存
                    if(table[loseloseHashCode(key)].isEmpty()){// 使用链表里面的isEmpty方法
                        table[loseloseHashCode(key)] = undefined;
                    }

                    return true;
                }

                // 链表向后移动
                current = current.next;
            }
        }
        else {
            // 散列值对应的元素不存在 直接返回undefined
            return '找不到要删除的元素';
        }
    }
}


var lll = new HashTable_L;
lll.put('Ana', 111);
lll.put('Donnie', 222)；

```

线性探查  
检查散列表中相同数值的后一个不为空的位置，存放第二个数据  
```
// 线性探查
var HashTable_X = function () {
    var table = []
    // 散列函数
    var loseloseHashCode = function (key) {
        var hash = 0;
        for (var i = 0; i < key.length; i++) {
            // 利用字符串遍历下标得到所有字符的ASCII值之和
            hash += key[i].charCodeAt();
        }
        return hash % 37;
    }

    // 辅助类
    var Node = function (key, value) {
        this.key = key;
        this.value = value;
    }

    this.put = function (key, value) {
        // 获取散列值
        var position = loseloseHashCode(key);
        if (table[position] == undefined) {
            // 如果散列值对应的位置没有元素 添加
            table[position] = new Node(key, value);
        }
        else {
            // 如果散列值对应的位置已经有元素了
            // 向后线性探查
            var index = position + 1;
            while (table[index] !== undefined) {


                index++;
            }
            table[index] = new Node(key, value);
        }
    }

    // 获取整个哈希表
    this.getItems = function () {
        return table;
    }
}

var xxx = new HashTable_X;
xxx.put('Ana', 111);
xxx.put('Donnie', 222);
```

## 更好的散列函数
原来的散列函数问题：散列值冲突率太高  
更好的算法djb2  
```
var djb2HashCode = function(key){
    var hash = 5381;
    for(var i = 0;i<key.length;i++){
        hash = hash *33 +key[i].charCodeAt();
    }
    return hash % 1013;
}
```

# 树
不对外暴露所有Node的方法  
外部只操作树
```
var Tree = function(){
    // 辅助类
    var Node = function(value){
        this.value = value;
        this.left = null;
        this.right = null;
    }


    var root = null;

    // 插入节点
    var insertNode = function(node,newNode){
        if(newNode.value > node.value){
            // 向右
            if(node.right == null){
                // 右边是空的 直接放置节点
                node.right = newNode;
            }
            else{
                // 右边不是空的 递归
                insertNode(node.right,newNode);
            }
        }
        else if(newNode.value < node.value){
            // 向左
            if(node.left == null){
                // 左边是空的 直接放置节点
                node.left = newNode;
            }
            else{
                // 左边不是空的 递归
                insertNode(node.left,newNode);
            }
        }
    }
    this.insert = function(value){
        // 树是空的
        // 插入的节点作为根节点
        var newNode = new Node(value)
        if(root == null){
            root = newNode;
        }
        else{
            insertNode(root,newNode);
        }
    }


    // 寻找
    this.search = function(value){}

    // 删除节点
    this.remove = function(value){}


    // 遍历树  
    var tra = function(node,callback){
        if(node == null) return
        tra(node.left,callback)
        tra(node.right,callback)
        callback(node.value)
    }
    this.traverse = function(callback){
        tra(root,callback);
    }


    // 找二叉树中最小的元素值
    var min = function(node){
        // 1、树本身是空的 2、树不是空的一直向左找
        if(node == null) return null;
        while(node && node.left){
            node = node.left;

        }
        return node.value;
    }
    this.min = function(){
        return min(root);
    }

    
    this.getRoot = function(){
        return root;
    }
}


var t = new Tree;

t.insert(8);
t.insert(2);
t.insert(3);
t.insert(9);
t.insert(1);


```

# 图






# 算法
大O表示法  
粗略的度量计算机效率的方式被称作大O表示法  
通常使用一种算法的速度会如何随着数据量的变化  

常见：  
O(1)  常数的  
O(logn) 对数的  
O(n) 线性的
O(nlogn) 线性和对数乘积  
O(n^2) 平方   
O(2^n) 指数的


# 排序算法

## 冒泡排序
## 选择排序
## 插入排序
## 归并排序

# 搜索算法
## 顺序搜索
## 二分搜索

# 算法模式
## 递归 动态规划 贪心算法
